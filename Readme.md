# Учим FASTAPI

## *Асинхронность*

### Про универсальный декоратор

- ***asyncio.iscoroutinefunction()*** - проверяет, является ли функция асинхронной, в качестве аргумента принимает функцию.


- ***@functools.wraps()*** - это короткий способ для применения функции ***functools.update_wrapper()***, которая:


    Копирует имя функции (__name__),
    Копирует строку документации (__doc__),
    Копирует информацию о модуле (__module__),
    Копирует другие атрибуты, такие как аннотации и т.д.
Другими словами позволяет сохранить функции свои метаданные.

*Пример:*

```def my_decorator(func):
    def wrapper(*args, **kwargs):
        print("Вызов декорированной функции")
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def say_hello():
    """Функция, которая говорит 'Hello!'"""
    print("Hello!")

print(say_hello.__name__)  # wrapper
print(say_hello.__doc__)   # None
```

Как видно, без использования **@functools.wraps**, декорированная функция **say_hello** потеряла своё имя (стала называться wrapper) и строку документации (__doc__ стала None).
Для корректной работы необходимо импортировать - ***import functools***

### Корутина

Корутина работает как генератор она поддерживает паузы в своей работе и может возвращать промежуточные значения. Как и генераторы, 
они могут возвращать значения, но используют не ключевое слово **yield**, а **await**. Это позволяет приостанавливать выполнение функции и возобновлять его позже.

- ***acync*** - явный флаг , что функция является асинхронной (корутиной)


- ***await*** - явный флаг, что в этом месте функция встает на паузу и дает работать другим, пока ждет свои данные.


- ***event loop*** - цикл событий, механизм, который отвечает за планирование и запуск корутин. Можно представить как список\очередь ,из которого в вечном цикле достаются и запускаются корутины.
В асинхронном программировании **event loop** запускается функцией **asyncio.run(my_coroutine())** [my_coroutine() - это название функции]*


### Работа с корутиной

- ***asyncio.gather*** - это функция из модуля asyncio, которая позволяет запускать несколько корутин одновременно и дождаться их завершения. Она принимает одну или несколько корутин, или задач и выполняет их параллельно. 
Основное назначение **asyncio.gather** — упрощение работы с множественными асинхронными операциями и объединение их результатов.
Подходит для простого случая, когда нужно запустить несколько корутин и собрать их результаты. Если одна из задач выбрасывает исключение, это исключение прерывает выполнение всех задач.
Если прописать - присвоить **return_exceptions=** значение **True**, то в случае возникновения исключений в одной или нескольких корутинах они будут возвращены как результат, а не приведут к завершению всей операции.
Это полезно, если вы хотите получить результаты всех задач, несмотря на ошибки.
**Всегда возвращает список -> List[Union[str, BaseException, None, Any]]**

*Пример:*
```import asyncio

async def task1():
    await asyncio.sleep(1)
    return 'Result from task1'

async def task2():
    await asyncio.sleep(2)
    return 'Result from task2'

async def main():
    results = await asyncio.gather(task1(), task2(),
        return_exceptions=True)
    print(results)

asyncio.run(main())
```

- ***asyncio.create_task*** — это функция, используемая для явного запуска корутины
как задачи (**task**) в фоновом режиме. 
Она позволяет начать выполнение корутины, не дожидаясь её завершения,
и возвращает объект задачи (**asyncio.Task**), с которым можно работать,
отслеживать его состояние и управлять выполнением.
Когда вы вызываете корутину напрямую с помощью **await**,
выполнение программы приостанавливается до тех пор,
пока корутина не завершится. В то время как **asyncio.create_task**
позволяет корутине начинать выполнение в фоновом режиме,
не останавливая выполнение основной программы. Это означает,
что программа продолжит выполняться дальше,
не дожидаясь завершения корутины.
Задачи, созданные с помощью **create_task**, могут выполняться
параллельно с другими задачами.
Можно управлять задачей следующим образом:  
**cancel()** - отменяет задачу. При попытке получить результат отменённой
задачи будет выброшено исключение **CancelledError**.  
**result()** - позволяет получить результат. Если задача завершилась
с исключением, оно будет поднято при вызове этого метода.
**done()** - проверяет статус, возвращает True, если задача завершена, 
и False, если она ещё выполняется.

*Пример:*
```import asyncio

async def example_task(task_name: str, delay: int) -> str:
    print(f"Task {task_name} started.")
    try:
        await asyncio.sleep(delay)
        return f"Task {task_name} completed after {delay} seconds."
    except asyncio.CancelledError:
        return f"Task {task_name} was cancelled."

async def main() -> None:
    # Создание задач с различными задержками
    task1 = asyncio.create_task(example_task("A", 5))
    task2 = asyncio.create_task(example_task("B", 2))

    # Проверяем статус задач до их завершения
    print(f"Task1 done: {task1.done()}")
    print(f"Task2 done: {task2.done()}")

    # Ждём некоторое время и отменяем task1
    await asyncio.sleep(1)
    task1.cancel()

    # Ожидаем завершения задач
    try:
        result1 = await task1
    except asyncio.CancelledError:
        print("Caught CancelledError for task1.")
        result1 = "Task1 was cancelled."

    result2 = await task2

    # Печатаем результаты
    print(result1)
    print(result2)

    # Проверяем статус задач после их завершения
    print(f"Task1 done: {task1.done()}")
    print(f"Task2 done: {task2.done()}")

asyncio.run(main())

Вывод в консоль:
Task A started.                   #Первая задача task1 ("A") начинает выполняться с задержкой 5 секунд.
Task B started.                   #Вторая задача task2 ("B") начинает выполняться с задержкой 2 секунды.
Task1 done: False                 #Проверяется статус задачи task1 сразу после её создания, и она ещё не завершена, поэтому выводится False
Task2 done: False                 #Проверяется статус задачи task2, и она также ещё не завершена, поэтому выводится False.
Task B completed after 2 seconds. #Задача task2 завершается через 2 секунды, и результат выводится.
Task A was cancelled.             #Через 1 секунду после запуска задач, task1 отменяется с помощью cancel(). При попытке получить результат этой задачи возвращается сообщение о том, что задача была отменена.
Task1 done: True                  #Проверяется статус задачи task1 после её отмены. Задача завершена (хотя и была отменена), поэтому выводится True.
Task2 done: True                  #Проверяется статус задачи task2 после её завершения, и она завершена успешно, поэтому выводится True.

```

- ***asyncio.as_completed*** — это функция, которая принимает набор корутин 
или задач и возвращает итератор, который выдает результаты по мере завершения 
этих задач в порядке их завершения, а не в порядке их запуска. Как это работает:
Когда вы работаете с несколькими асинхронными задачами, зачастую важно знать, 
какая задача завершится первой, чтобы начать обработку её результата как можно 
раньше. **asyncio.as_completed** позволяет вам начать обработку результатов 
сразу по мере их готовности, не дожидаясь завершения всех задач.
Функция принимает параметры:  
**tasks (Iterable[Awaitable])** - Список или другой итерируемый объект корутин 
или задач.  
***timeout (Optional[float])*** - Максимальное время ожидания завершения всех задач. 
Если какое-то из заданий не завершится до этого времени, оно будет пропущено.
Возвращается асинхронный итератор, который возвращает задачи по мере их 
завершения.

*Пример:*

```import asyncio

async def task(delay: int) -> int:
    await asyncio.sleep(delay)
    return delay

async def main():
    tasks = [task(3), task(2), task(1)]
    
    # Получаем результаты по мере завершения
    for coro in asyncio.as_completed(tasks):
        result = await coro
        print(f"Task completed with result: {result}")

asyncio.run(main())

Вывод в консоль:

Task completed with result: 1
Task completed with result: 2
Task completed with result: 3
```

- ***asyncio.wait*** — это функция, которая позволяет запускать множество 
задач и контролировать их выполнение. В отличие от **asyncio.gather**, 
которая возвращает результаты всех задач, **asyncio.wait** возвращает две 
группы задач: завершённые и незавершённые.  
Как это работает:  
**asyncio.wait** запускает все переданные задачи и позволяет вам следить 
0за их состоянием. Вы можете выбрать, ждать завершения всех задач или 
только первой завершившейся, управляя тем, как долго функция будет ожидать.  
Параметры:  
**tasks (Iterable[Awaitable])**: Список или другой итерируемый объект 
корутин или задач.  
**timeout (Optional[float])**: Максимальное время ожидания завершения задач. 
Если задачи не завершатся за это время, они будут возвращены как 
незавершённые.  
**return_when (Optional[str])**: Определяет, когда wait должен завершить 
ожидание. Возможные значения:  
*asyncio.ALL_COMPLETED*: Ждать завершения всех задач.
*asyncio.FIRST_COMPLETED*: Ждать завершения хотя бы одной задачи.
*asyncio.FIRST_EXCEPTION*: Ждать завершения первой задачи с исключением 
или завершения всех задач, если исключений не было.  
Возвращаемое значение:  
Кортеж из двух множеств:  
**done**: Задачи, которые завершились.  
**pending**: Задачи, которые ещё выполняются (или были отменены).  
-> Tuple[Set[Awaitable], Set[Awaitable]]:
*Пример:*

```import asyncio

async def task(delay: int) -> int:
    await asyncio.sleep(delay)
    return delay

async def main():
    tasks = [task(3), task(2), task(1)]
    
    # Ожидаем завершения всех задач
    done, pending = await asyncio.wait(tasks, return_when=asyncio.ALL_COMPLETED)
    
    # Обрабатываем завершённые задачи
    for task in done:
        print(f"Task result: {task.result()}")

asyncio.run(main())


Вывод:

Task result: 1
Task result: 2
Task result: 3
```

*Пример с FIRST_COMPLETED:*
```async def main():
    tasks = [task(3), task(2), task(1)]
    
    # Ожидаем завершения хотя бы одной задачи
    done, pending = await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)
    
    print(f"Completed tasks: {len(done)}")
    print(f"Pending tasks: {len(pending)}")

asyncio.run(main())

Вывод:

Completed tasks: 1
Pending tasks: 2

```
