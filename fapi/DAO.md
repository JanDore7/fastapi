Паттерн Репозиторий (или DAO — Data Access Object) 
используется для абстракции доступа к данным, 
разделяя логику бизнес-правил и взаимодействия с базой данных. 
Репозиторий предоставляет интерфейс для работы с сущностями, 
скрывая детали реализации хранения и извлечения данных. 
Это позволяет легче изменять источник данных, 
тестировать бизнес-логику и поддерживать код. 
Важно, чтобы репозиторий имел методы для основных операций, 
таких как добавление, обновление, удаление и поиск данных.  

**Основные концепции**  

1. Изоляция логики доступа к данным: 
Паттерн отделяет бизнес-логику приложения от логики доступа к данным.
Это значит, что изменения в способах хранения данных (например, 
переход с SQL на NoSQL) не требуют изменения бизнес-логики.    

2. Интерфейс: Репозиторий обычно предоставляет интерфейс, 
который описывает методы для выполнения операций с данными. Например:  

**add(entity)**
**update(entity)**
**delete(entity)**
**find_by_id(id)**
**find_all()**

Реализация: Конкретная реализация репозитория взаимодействует с базой данных через ORM или напрямую с SQL-запросами. 
Например, в Python это может быть SQLAlchemy.  

**Преимущества**

Упрощение тестирования: Репозитории можно легко заменять 
на заглушки (моки) при юнит-тестировании, 
что позволяет изолировать тесты от базы данных.  

Чистота кода: Бизнес-логика остаётся чистой и сосредоточенной 
на решении задач, без учета нюансов доступа к данным.  

Переиспользование кода: Логика доступа к данным может 
быть переиспользована в разных частях приложения или даже 
в других проектах.  

Пример реализации

Вот простой пример на Python с использованием SQLAlchemy:
```aiignore
from sqlalchemy.orm import sessionmaker

class User:
    def __init__(self, id, name):
        self.id = id
        self.name = name

class UserRepository:
    def __init__(self, session):
        self.session = session

    def add(self, user):
        self.session.add(user)
        self.session.commit()

    def find_by_id(self, user_id):
        return self.session.query(User).filter_by(id=user_id).first()

    def find_all(self):
        return self.session.query(User).all()

    def delete(self, user):
        self.session.delete(user)
        self.session.commit()

```
Как использовать

В вашем коде вы создаете экземпляр UserRepository, передавая ему сессию SQLAlchemy, 
и затем вызываете методы репозитория для взаимодействия с данными:  
```aiignore
Session = sessionmaker(bind=engine)
session = Session()

user_repo = UserRepository(session)

# Добавление пользователя
new_user = User(id=1, name="Alice")
user_repo.add(new_user)

# Поиск пользователя
user = user_repo.find_by_id(1)
print(user.name)

# Удаление пользователя
user_repo.delete(user)

```

# [Назад к Алхимии ...](sqlalchemy_and_alembic.md)