Проблема "N+1" (или "N+1 запросов") — это распространенная проблема производительности в работе с базами данных, особенно в ORM, таких как SQLAlchemy.
В чем суть проблемы "N+1"?

Суть проблемы заключается в том, что при выполнении запроса к базе данных для выборки сущностей и связанных с ними данных ORM может генерировать один основной запрос, а затем дополнительные запросы для каждой записи (объекта) из результатов первого запроса. Это ведет к тому, что вместо того чтобы выполнить один сложный запрос с соединением (JOIN), ORM генерирует N+1 запросов (где N — это количество записей).
Пример проблемы "N+1"

Допустим, у вас есть две связанные таблицы:

User (пользователи)  
Address (адреса пользователей)  

Каждый пользователь может иметь несколько адресов, и вы хотите получить всех пользователей и их адреса.
Неправильный подход (создает проблему "N+1"):

Предположим, вы выполняете запрос для выборки всех пользователей, а затем для каждого пользователя ORM выполняет отдельный запрос, чтобы получить его адреса.

```aiignore
users = session.query(User).all()

for user in users:
    print(user.name)
    # Для каждого пользователя делается отдельный запрос для его адресов
    print(user.addresses)

```
Что здесь происходит:

Выполняется первый запрос для получения всех пользователей:  


>SELECT * FROM user;

Затем для каждого пользователя выполняется дополнительный 
запрос для получения его адресов. 
Если у вас 100 пользователей, ORM выполнит 100 дополнительных запросов:
```aiignore
SELECT * FROM address WHERE address.user_id = 1;
SELECT * FROM address WHERE address.user_id = 2;
...
SELECT * FROM address WHERE address.user_id = 100;

```

Итого: 1 запрос для пользователей + 100 запросов для их адресов = 101 запрос (что и называется "N+1").
Правильный подход (избегает проблему "N+1"):  

Чтобы избежать выполнения дополнительных запросов для каждого пользователя, 
можно использовать предзагрузку связанных данных с помощью методов вроде 
joinedload() или subqueryload(). Это заставит ORM загрузить пользователей 
и их адреса в одном запросе.
```aiignore
from sqlalchemy.orm import joinedload

# Предзагрузка адресов вместе с пользователями
users = session.query(User).options(joinedload(User.addresses)).all()

for user in users:
    print(user.name)
    print(user.addresses)  # Теперь адреса уже загружены вместе с пользователями

```
Что здесь происходит:  

Один запрос для получения пользователей и их адресов:  
```aiignore
SELECT * FROM user
JOIN address ON user.id = address.user_id;

```

Теперь всего один запрос загружает и пользователей, и их адреса, независимо от количества записей.
Как избежать проблемы "N+1"?  

Использование предзагрузки (joinedload, subqueryload, selectinload):  
Эти методы позволяют загружать связанные данные эффективно.  
Например, joinedload использует JOIN в SQL для выборки всех данных за один запрос, а subqueryload использует подзапросы.  

Правильное проектирование запросов:  
При работе с ORM важно осознавать структуру данных и количество 
связанных объектов, чтобы минимизировать количество запросов.  

Когда проблема "N+1" может стать критической?  

Проблема "N+1" становится особенно заметной, когда:  

Много связанных объектов: 
Если есть множество связанных объектов (например, 
сотни или тысячи записей), 
выполнение отдельного запроса для каждого может 
привести к значительным задержкам.  
Частые обращения к базе данных: 
Каждая операция с базой данных имеет свою цену. 
Если вместо одного запроса выполняется множество отдельных запросов, 
это увеличивает время выполнения и нагрузку на сервер базы данных.  

Резюме

Проблема "N+1" возникает, когда вместо одного запроса для получения
связанных данных ORM выполняет множество дополнительных запросов 
(по одному на каждую запись). Чтобы избежать этой проблемы, 
можно использовать механизмы предзагрузки данных, 
такие как joinedload или subqueryload, 
что позволит уменьшить количество запросов и повысить
производительность приложения.  

[Назад ...](sqlalchemy_and_alembic.md)